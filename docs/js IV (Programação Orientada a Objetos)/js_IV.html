<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Js IV (POO)</title>
  </head>
  <body>
    <h1>Funções construtoras</h1>
    <br />
    <h4>
      Vamos criar uma pasta com o nome "funcao Construtora", dentro dessa pasta
      um ficheiro js com o nome "funcaoConstrutora.js"
    </h4>
    <br />
    <h3>
      As funções construtoras começam com a primeira letra maiúscula
      (Pascalcase)
    </h3>
    <h4>function Book(title, pages, tags, author){</h4>
    <h4>this.title = title</h4>
    <h4>this.pages = pages</h4>
    <h4>this.tags = tags</h4>
    <h4>this.author = author</h4>
    <h4>this.published = false</h4>
    <h4>this.inStock = 0</h4>
    <h4>this.addToStock = function(quantity){this.inStock+= quantity}</h4>
    <h4>this.save = function(){/*Guardar-Dados*/}</h4>
    <h4>}</h4>
    <br />
    <h3>
      Para utilizarmos esta função para nos devolver um livro, utilizámos a
      palavra "new", ou seja:
    </h3>
    <h4>
      criamos uma variavel com o nome do livro que queremos, dizemos que essa
      variável recebe um "new" Book(); Depois é so passar os parâmetros que a
      função construtora que criamos tem.
    </h4>
    <h4>const tags = ["Fantasy","Adventure"]</h4>
    <h4>const author = {name: "Christopher Peolini"}</h4>
    <h4>const aragon = new Book("Eragon",468, tags, author)</h4>
    <h4>console.log(aragon)</h4>
    <br />
    <h3>Agora se executarmos isto no terminal: node funcao_construtora.js</h3>
    <h4>
      Conseguimos ver o nosso objeto e antes do objeto, no terminal conseguimos
      ver o "tipo" deste objeto. Neste caso é como se fosse do tipo "Book", que
      foi o constutor que usamos para contruir o objeto.
    </h4>
    <br />
    <h3>Agora vamos criar outro objeto do tipo Book</h3>
    <h4>const eldest = new Book("Eldest",644, tags, author)</h4>
    <h4>console.log(eldest)</h4>
    <h3>Executamos o node no terminal: node funcao_construtora.js</h3>
    <h4>Conseguimos ver que temos 2 objetos do mesmo "tipo" Book.</h4>
    <br />
    <hr />
    <br />
    <h1>
      O que é Programação Orientada a Objetos (POO) / Object-Oriented
      Programming (OOP)
    </h1>
    <br />
    <h4>
      Programação orientada a objetos é: Um paradigma de programação, ou seja,
      um conjunto de conceitos e recursos de linguagem que guiam a forma como
      programamos
    </h4>
    <h4>Tem como peça central os objetos e a forma como eles se comunicam</h4>
    <h4>Os objetos podem conter dados (atributos) e código (métodos)</h4>
    <h4>Outros dois termos importantes na POO/OOP são classes e instâncias:</h4>
    <h5>Classes: são como fábricas de objetos a partir de uma "fôrma"</h5>
    <h5>Instâncias: são os objetos fabricados pelas classes</h5>
    <br />
    <hr />
    <br />
    <h1>Classes e Instâncias</h1>
    <br />
    <h3>
      Vamos criar uma pasta com o nome "Classes e Instancias", dentro dessa
      pasta um ficheiro js com o nome "Book.js" (primeira letra em maiúscula
      (Pascalcase) é uma boa prática e o nome do ficheiro ser o nome da classe)
      <strong>também</strong>)
    </h3>
    <br />
    <h3>Criar uma class:</h3>
    <h4>class Book{</h4>
    <h4>constructor(title){</h4>
    <h4>this.title = title</h4>
    <h4>}</h4>
    <h4>}</h4>
    <h3>
      A class funciona quase como as funções construtoras, apenas os parâmetros
      são passados no método "constructor" que é como se fosse uma função;<br />
      Depois, dentro desse método temos acesso a outro metodo que é o "this";<br />
      Conseguimos dizer que o título (this.title) do objeto (instancia) que
      utilizar esta classe (Book) recebe o parâmetro da classe Book chamado pela
      instância: this.title = title
    </h3>
    <br />
    <h3>Criar uma instância:</h3>
    <h4>const livroX = new Book("X")</h4>
    <h3>
      Basicamnete a instância é cada livro que use a classe book, ou seja:
    </h3>
    <h3>O nosso "livroX" é uma instância da classe "Book"</h3>
    <br />
    <h4>console.log(livroX)</h4>
    <h4>Executamos o node no terminal: node Book.js</h4>
    <h4>Podemos ver que temos o nosso objeto com o título</h4>
    <br />
    <h3>Vamos criar outra instância da classe "Book":</h3>
    <h4>const livroY = new Book("Y")</h4>
    <h4>console.log(livroY)</h4>
    <br />
    <h3>Instancias: livroX ; livroY</h3>
    <h3>Classe: Book</h3>
    <h3>
      Dica: Não esquecer que os parâmetros das classes são passados no metodo
      "constructor" que funciona como uma função e depois temos acesso ao metodo
      "this".
    </h3>
    <br />
    <h3>Métodos nas classes:</h3>
    <h3>
      Vamos adicionar à nossa class uma chave default chamado "published" e
      dizer que começa sempre em false, ou seja, que o valor da chave seja
      false: this.published = false
    </h3>
    <h4>class Book{</h4>
    <h4>constructor(title){</h4>
    <h4>this.title = title</h4>
    <h4>this.published = false</h4>
    <h4>}</h4>
    <h3>
      Agora vamos criar um método "publish()", para quando for chamado, passe o
      published para "true"
    </h3>
    <h3>
      Fazemos isso fora do metodo "constructor" mas dentro da class Book{}.
    </h3>
    <h4>publish(){</h4>
    <h4>this.published = true</h4>
    <h4>}</h4>
    <h4>}</h4>
    <br />
    <h4>Agora se chamarmos o metodo publish na instacia "livroY"</h4>
    <h4>livroY.publish()</h4>
    <h4>Vamos ver na consola as duas instâncias novamente:</h4>
    <h4>console.log(livroX)</h4>
    <h4>console.log(livroY)</h4>
    <h3>
      Agora podemos ver que depois de chamarmos o metodo publish na instacia
      "livroY", o published passou a true nessa instância
    </h3>
    <br />
    <h3>
      Para vermos se uma certa instãncia pertence a uma certa class, podemos
      usar o metodo "intanceof":
    </h3>
    <h4>console.log(livroX instanceof Book)</h4>
    <h4>console.log([livroX,livroY] instanceof Array</h4>
    <h3>Ambos são True</h3>
    <h4>console.log(livroy instanceof String)</h4>
    <br />
    <hr />
    <br />
    <h1>Associação</h1>
    <br />
    <h3>O que é uma associação:</h3>
    <h4>
      Associação é um relacionamente entre classes que permite que uma instância
      de uma classe faça a outra realizar uma ação
    </h4>
    <h4>
      É como dizer para a aplicação que um objeto de um tipo está conectado, ou
      depende, de um objeto de outro tipo
    </h4>
    <h3>Exemplos:</h3>
    <h4>
      Objetos de uma classe Person possuem um atributo que é um objeto da classe
      Address
    </h4>
    <h4>
      Objetos de uma classe Product possuem um atributo que é um array de
      objetos da classe Category
    </h4>
    <h3>Vamos ver na pratica:</h3>
    <h3>
      Vamos criar uma pasta com o nome "associacao" com o ficheiro "Person.js" e
      "Address.js"
    </h3>
    <h3>Dentro do ficheiro "Address.js":</h3>
    <h3>Criamos uma class Address</h3>
    <h4>class Address{}</h4>
    <h3>Passamos parametros na classe</h3>
    <h4>constructor(street, number, neighborhood, city, state){</h4>
    <h4>this.street = street</h4>
    <h4>this.neighborhood = neighborhood</h4>
    <h4>this.city = city</h4>
    <h4>this.state = state</h4>
    <h4>}</h4>
    <h3>Agora vamos criar um metodo dentro da classe chamado "fullAddress"</h3>
    <h4>fulladdress(){</h4>
    <h4>
      return `Rua ${this.street}, nº ${this.number}. ${neighborhood},
      ${this.city}/${this.state}.`
    </h4>
    <h4>}</h4>
    <h4>}</h4>
    <h3>
      Agora utilizamos o commonJs para exportar a nossa classe Address, para
      podermos usá-la noutro arquivo
    </h3>
    <h4>module.exports = Address</h4>
    <br />
    <h3>No ficheiro "Person.js":</h3>
    <h3>Criamos uma class Person</h3>
    <h4>class Person{}</h4>
    <h3>Passamos 2 parametros na classe: name and address</h3>
    <h4>constructor(name, address){</h4>
    <h4>this.name = name</h4>
    <h4>this.address = address</h4>
    <h4>}</h4>
    <h4>}</h4>
    <h3>
      Agora utilizamos o commonJs para exportar a nossa classe Person, para
      podermos usá-a noutro arquivo
    </h3>
    <h4>module.exports = Person</h4>
    <br />
    <h3>Agora criamos outro ficheiro com o nome: index.js</h3>
    <h3>importamos os nossos modulos</h3>
    <h4>const Address = require("./Address")</h4>
    <h4>const Person = require ("./Person")</h4>
    <h3>
      Agora criamos duas variaveis que recebam as classes e passamos os
      parâmetros necessários
    </h3>
    <h4>
      const addr = new Address("rua das flores", 5,"bairroX", "Porto", "Porto")
    </h4>
    <h4>const cunha = new Person("Claudio Cunha", addr)</h4>
    <br />
    <h3>
      Agora vamos dar console.log no "cunha" e como temos acesso à classe
      "Address", conseguimos executar o metodo também, por isso vamos dar
      console.log(cunha.Address.fullAddress
    </h3>
    <h4>console.log(cunha)</h4>
    <h4>console.log(cunha.address.fullAddress())</h4>
    <h4>Abrimos o terminal e executamos com o node: node index.js</h4>
    <h3>
      Como dá pra ver, conseguimos associar estes dois objetos: o objeto da
      classe Person tem uma referência ao objeto da classe Address; Por isso
      temos acesso aos metodos e atributos da classe Address
    </h3>
    <br />
    <h3>
      Esta é uma das formas que temos de fazer "associacão" entre as classes e
      os objetos. Passando diretamente um objeto de outra classe
    </h3>
    <br />
    <h3>Existem mais formas de se fazer</h3>
    <h3>
      Podiamos fazer diretamente dentro da class Person (ficheiro Person.js):
    </h3>
    <h3>
      Era so passar mais parametros no "constructor" e depois o nosso
      this.address recebia a nossa classe Address
    </h3>
    <h4>const address = require("address")</h4>
    <h4>class Person{</h4>
    <h4>constructor(name,street,number,neighborhood,city,state){</h4>
    <h4>this.name = name</h4>
    <h4>
      this.address = new Address(street, number, neighborhood, city, state)
    </h4>
    <h3>Agora no nosso ficheiro "index.js"</h3>
    <h4>
      Já não precisamos do: const addr = new Address("rua das flores", 5,
      "bairroX", "Porto", "Porto");
    </h4>
    <h3>Podiamos passar tudo diretamente na classe Person:</h3>
    <h4>
      const cunha = new Person("Claudio Cunha", "rua das flores", 5, "bairroX",
      "Porto", "Porto")
    </h4>
    <h3>Antes a classe Person, não dependia de nenhuma outra classe.</h3>
    <h3>Agora a classe Person, depende da classe Address</h3>
    <h3>Estão associadas</h3>
    <br />
    <hr />
    <br />
    <h1>Encapsulamento</h1>
    <br />
    <h3>
      Encapsulamento é o princípio de impedir que determinadas partes de uma
      classe sejam acessíveis pelo contexto exterior
    </h3>
    <h3>No javaScript existem 2 niveis de encapsulamento:</h3>
    <h4>
      Publico: Onde o atributo/método é acessível fora da classe (default)
    </h4>
    <h4>
      Privado: Onde o atributo/método só é acessível dentro da própria classe
    </h4>
    <h3>
      Para definirmos um atributo ou método como privado utilizamos um # no
      começo do seu nome
    </h3>
    <h3>
      Todo atributo ou método que não for privado será automaticamente público
    </h3>
    <h3>Trabalha com o conceito: Abstração</h3>
    <p>
      Funciona desta maneira: Um método executa vários passos dentro dele, a
      pessoa não precisa de saber quais são aqueles passos
    </p>
    <p>
      imaginem que temos um Carro; Nós não precisamos de saber exatamente o que
      o carro faz quando rodamos a chave e ele liga... Nós só precisamos de
      saber que temos que virar a chave para o carro ligar.
    </p>
    <h4>
      Isto chama-se Abstração. Todo o comportamento complexo e dificil é
      ocultado do utilizador e o utilizador fica com a parte mais simples de
      trabalhar. O ENCAPSULAMENTO ajuda com isto também
    </h4>
    <br />
    <h3>Exemplos:</h3>
    <h3>Porquê que haveriamos de querer encapsular as coisas numa classe?</h3>
    <h4>
      Imaginem uma classe que tem um atributo que é definido uma vez durante a
      construção (password ou balance$), depois, como é obvio não pode ser
      alterado diretamente (a usar: obj.balance = 9999 / obj.password = "Mudei a
      tua password"). Nós queremos que esses atributos só possam ser
      vistos/mudados pela pessoa própria pessoa e não por qualquer pessoa
    </h4>
    <h4>
      Imaginem uma classe que possui um método principal que internamente chama
      vários outros métodos da própria classe que não fazem sentido
      individualmente ou chama um método muito complexo que o utilizador vulgar
      não sabe como funciona. Nós queremos que o utilizador use o método mais
      facil e que esse método facil encapsule e abstraia o método dificil
    </h4>
    <br />
    <h3>Ver na prática como criamos estes atributos e métodos privados:</h3>
    <br />
    <h3>
      Vamos criar uma pasta com o nome "Encapsulamento" e dentro da pasta
      criamos uma classe "Account.js"
    </h3>
    <h4>
      Criamos o construtor dessa classe e como parâmetro vai receber um "user":
      constructor(user){
    </h4>
    <h4>this.email = user.email</h4>
    <h4>this.password = user.password</h4>
    <h4>this.balance = 0</h4>
    <h4>}</h4>
    <br />
    <h3>Agora conseguimos criar objetos desta classe</h3>
    <h4>const user = {</h4>
    <h4>email: "cunha@email.com",</h4>
    <h4>password: adminadmin</h4>
    <h4>}</h4>
    <h3>
      Feito o "user", Agora podemos criar uma conta com a classe que criamos
    </h3>
    <h4>const myAccount = new Account(user)</h4>
    <h3>Podemos executar o node no terminal para ver: node Account.js</h3>
    <br />
    <h3>
      Com isto, nós conseguimos mexer no "myAccount" e mudar a password e o
      valor que esse user tem
    </h3>
    <h4>myAccount.password = "12345"</h4>
    <h4>myAccount.balance = 99999999</h4>
    <br />
    <h3>
      Podemos executar o node para vermos que realmente está diferente: node
      Account.js
    </h3>
    <br />
    <h3>
      Agora, como é obvio, nós queremos que não seja possível mexer nesses 2
      valores, porque são valores privados.
    </h3>
    <h3>Para fazer isso, precisamos de adicionar o # antes do nome</h3>
    <h4>this.#password = user.password</h4>
    <h4>this.#balance = user.balance</h4>
    <h3>
      Tambem precisamos de definir quais são estes atributos privados fora do
      constructor mas dentro da classe
    </h3>
    <h4>#password</h4>
    <h4>#balance</h4>
    <h3>
      Até conseguimos tirar o balance do constructor e pôr um valor default aqui
    </h3>
    <h4>#balance = 0</h4>
    <br />
    <h3>
      Agora, reparem que a nossa password e balance mudou para #password e
      #balance, ou seja, para alterar como alterámos em cima (com a mesma
      logica) seria:
    </h3>
    <h4>myAccount.#password = "12cl345"</h4>
    <h4>myAccount.#balance = 99999999</h4>
    <h3>
      Escrevendo isso, vamos ver que temos um erro. Diz que o valor é privado
    </h3>
    <br />
    <h3>
      Agora para termos acesso a estes valores (por exemplo, o balance da
      conta), podemos usar um método dentro da classe
    </h3>
    <h4>getBalance(email,password){</h4>
    <h4>if(this.email === email && this.#password === password){</h4>
    <h4>return this.#balance</h4>
    <h4>}else{console.log("Não tens acesso!")</h4>
    <br />
    <h3>Agora só conseguimos ter acesso se os dados tiverem certos:</h3>
    <h4>console.log(myAccount.getBalance()) //Não nos vai dar acesso</h4>
    <h4>
      console.log(myAccount.getBalance("email@mail.com", "12345") //Não nos vai
      dar acesso
    </h4>
    <h4>
      console.log(myAccount.getBalance("cunha@email.com","adminadmin") //Vai
      dar-nos acesso
    </h4>
    <br />
    <h3>
      Agora vamos continuar o nosso exemplo escrito em cima, passar para o 2:
      Vamos mexer neste método que criamos e abstraí-lo noutro método privado!
    </h3>
    <h3>
      Então vamos criar o metodo "authenticate", privá-lo e usar como parametro
      um email e uma senha, para que o método faça uma verificação (a mesma que
      fizemos em cima e apagamos ou comentamos no if do método getBalance():
    </h3>
    <h4>#authenticate(email,password){</h4>
    <h4>return this.email == email && this.password == password</h4>
    <h3>
      Esta função vai retornar um valor bolean (true or false) baseado na nossa
      condição (se o email for igual ao email que está guardado e a password
      igual à password que está guardada, dá-nos TRUE; se for o email for
      diferente ao email que está guardado e a password for diferente à password
      que está guardada, dá-nos FALSE)
    </h3>
    <br />
    <h3>
      Agora no if do método getBalance(), passamos o método que criamos
      (authenticate): if(this.#authenticate(email,password))
    </h3>
    <h4>if(this.#authenticate(email,password)){</h4>
    <h4>return this.#balance</h4>
    <h4>}else { return null</h4>
    <h4>}</h4>
    <br />
    <h3>executamos o node para ver: node Account.js</h3>
    <br />
    <h3>O ficheiro fica:</h3>
    <h4>class Account {</h4>
    <h4>constructor(user) {</h4>
    <h4>this.email = user.email;</h4>
    <h4>this.password = user.password;</h4>
    <h4>this.balance = 0;</h4>
    <h4>}</h4>
    <h4>}</h4>
    <h4>const userX = {</h4>
    <h4>email: "cunha@email.com",</h4>
    <h4>password: "adminadmin",</h4>
    <h4>};</h4>
    <h4>const newAccount = new Account(userX);</h4>
    <h4>console.log(newAccount);</h4>
    <h4>newAccount.password = "Mudei-te a pw";</h4>
    <h4>console.log(newAccount);</h4>
    <h4>//Vou fazer as alterações noutro ficheiro "Account2.js" --></h4>
    <h4>class Account {</h4>
    <h4>#password;</h4>
    <h4>#balance = 0;</h4>
    <h4>constructor(user) {</h4>
    <h4>this.email = user.email;</h4>
    <h4>this.#password = user.password;</h4>
    <h4>}</h4>
    <h4>/*getBalance(email, password) {</h4>
    <h4>if (this.email == email && this.#password == password) {</h4>
    <h4>return this.#balance;</h4>
    <h4>} else {</h4>
    <h4>console.log("Não tens acesso!");</h4>
    <h4>}</h4>
    <h4>}*/</h4>
    <h4>getBalance(email, password) {</h4>
    <h4>if (this.#authenticate(email, password)) {</h4>
    <h4>return this.#balance;</h4>
    <h4>} else {</h4>
    <h4>console.log("Não tens acesso!");</h4>
    <h4>}</h4>
    <h4>}</h4>
    <h4>#authenticate(email, password) {</h4>
    <h4>return this.email == email && this.#password == password;</h4>
    <h4>}</h4>
    <h4>}</h4>
    <h4>const userC = {</h4>
    <h4>email: "cunha@email.com",</h4>
    <h4>password: "adminadmin",</h4>
    <h4>};</h4>
    <h4>const newAccount = new Account(userC);</h4>
    <h4>console.log(newAccount);</h4>
    <h4>//newAccount.#password = "12345";</h4>
    <h4>//newAccount.#balance = 99999999;</h4>
    <h4>console.log(newAccount.getBalance());</h4>
    <h4>console.log(newAccount.getBalance("email@mail.com", "12345"));</h4>
    <h4>
      console.log(newAccount.getBalance("cunha@email.com", "adminadmin"));
    </h4>
    <br />
    <h3>
      Imaginem se o método "authenticate()" fosse muito complicado e complexo,
      nós conseguiamos fazer com que o método que o utilizador usasse fosse a
      parte facil. O método complicado estava abstraído
    </h3>
    <h3>Isto é o <strong>encapsulamento</strong>.</h3>
    <br />
    <hr />
    <br />
    <h1>Herança</h1>
    <br />
    <h4>
      Herança é um recurso que permite criar classes que incluem, ou "herdam"
      para ser mais preciso, todos os atributos e métodos de uma outra classe
    </h4>
    <h4>
      À classe que é herdada damos o nome de <strong>"superclass"</strong> (ou
      classe mãe), e à classe que herda, damos o nome de
      <strong>"subclass" (ou classe filha)</strong>
    </h4>
    <h4>
      Uma classe filha (subclass) possui todos os atributos e métodos da classe
      mãe, mas também pode possuir os seus próprios (que serão exclusivos dela)
    </h4>
    <h4>
      Uma classe consegue herdar outra com a palavra: extends
      nome_da_superclass(classe mãe){Aqui dentro podemos definir um constructor
      que recebe os seus próprios parâmetros e também os parametros que queremos
      herdar da classe mãe; Dentro da função constructor com a palavra "super()"
      indicámos os parâmetros da classe mãe}
    </h4>
    <h3>Exemplos:</h3>
    <h4>
      Imagina uma classe User que possui os seus atributos e métodos. Poderíamos
      ter classes AdminUser, EditorUser e StandardUser que são todas filhas de
      User, mas cada uma também possui os seus próprios atributos e métodos
    </h4>
    <h4>
      Ou ainda uma classe Property (como num imóvel) pode ser a classe mãe das
      classes filhas House e Apartment
    </h4>
    <br />
    <h3>Vamos ver na pratica</h3>
    <h3>Criamos uma pasta com o nome "herança" com o ficheiro "index.js"</h3>
    <h3>
      Nesse ficheiro criamos a classe Property com os parâmmetros area e preço;
      Também criamos um método para ver o preço do metro quadrado
      (getPricePerSquareMeter)
    </h3>
    <h4>class Property{</h4>
    <h4>constructor(price, area){</h4>
    <h4>this.price = price</h4>
    <h4>this.area = area</h4>
    <h4>}</h4>
    <h4>getPricePerSquareMeter(){</h4>
    <h4>return this.price / this.area</h4>
    <h4>}</h4>
    <h4>}</h4>
    <h3>
      Agora vamos criar a classe House e herdar a classe Property (extends)
    </h3>
    <h4>class House extends Property{}</h4>
    <h3>
      Criamos uma instância (const land) da class Property (new Property) com os
      seus parâmetros (50000, 200)
    </h3>
    <h4>const land = new Property(50000, 200)</h4>
    <h3>
      Agora criamos uma instância (const someHouse) da classe House() e se
      virmos bem, a classe house traz-nos um constructor com os parâmetros da
      class Porperty; Mesmo que tenhamos definido nada em cima (no extends a
      classe em branco)
    </h3>
    <h4>const someHouse = new House(200000, 120)</h4>
    <h3>
      Agora podemos dar um console.log nos dois objetos (as duas instâncias)
    </h3>
    <h4>console.log(land)</h4>
    <h4>console.log(someHouse)</h4>
    <h3>executamos o node para ver o resultado: node index.js</h3>
    <h4>Podemos ver que está tudo certo</h4>
    <h3>
      Outra coisa é que também podemos usar o método que criamos na classe
      Property, na instância someHouse
    </h3>
    <h4>console.log(someHouse.getPricePerSquareMeter())</h4>
    <h3>executamos o node: node index.js</h3>
    <h4>Podemos ver o resutado</h4>
    <h3>
      Lembram-se do que se usa para ver se um objeto é uma instância de uma
      determinada classe? instanceof
    </h3>
    <h3>Então vamos ver:</h3>
    <h3>se o objeto someHouse é uma instância da classe House;</h3>
    <h3>se o objeto someHouse é uma instância da classe Property;</h3>
    <h4>console.log(someHouse instaceof House)</h4>
    <h4>console.log(someHouse instaceof Property)</h4>
    <h3>Executamos com node: node index.js</h3>
    <h3>
      As duas são verdadeiras, o objeto someHouse é uma instância de ambas
      classes
    </h3>
    <br />
    <h3>
      Agora vamos criar outra class (Apartment) e dizer que também herda de
      Property
    </h3>
    <h4>class Apartment extends Property{}</h4>
    <h3>
      Dentro escrevemos o constructor com os parâmetros da classe Apartment e os
      parâmetros que queremos usar da class mãe (Property)
    </h3>
    <h4>constructor(number, price, area){}</h4>
    <h3>
      Dentro da função constructor, referenciamos o parâmetro da própria função
      com o "this.number=number" e os parâmetros da função mãe com a palavra
      "super()"; Os parâmetros da função mãe, têm de vir sempre em primeiro!!
    </h3>
    <h4>super(price, area)</h4>
    <h4>this.number = number</h4>
    <h4>}</h4>
    <h3>
      Agora podemos criar um método próprio para a nossa classe Apartment, por
      exemplo um método para vermos o andar: getFloor(){}
    </h3>
    <h4>getFloor(){</h4>
    <h4>
      return `O teu Apartamento está no: ${this.number.slice(0,-2)}º Andar`
      //Aqui usamos o método slice (a pensar que nos vão dar uma string) para
      dizer que queremos guardar uma parte dessa string: Queremos a string toda
      (0) excepto os ultimos 2 caracteres (-2). o -1 refere-se ao fim da string,
      o -2 é o penultimo caractere
    </h4>
    <h4>}</h4>
    <h3>Agora vamos criar uma instância da classe Apartment</h3>
    <h4>const apt = new Apartment("201",100,160000)</h4>
    <h3>Damos um console.log desta instancia</h3>
    <h4>console.log(apt)</h4>
    <h3>Executamos com o node: node index.js</h3>
    <h4>Conseguimos ver o objeto completo com o number, price e area...</h4>
    <h3>
      Conseguimos também ver o andar deste apartamento se usarmos o método que
      criamos "getFloor()"
    </h3>
    <h4>console.log(apt.getFloor())</h4>
    <h3>
      Se executarmos com o node, vai mostrar-nos que o nosso apartamento
      encontra-se no 2º andar
    </h3>
    <br />
    <hr />
    <br />
    <h1>Polimorfismo</h1>
    <br />
    <h4>
      Polimorfismo é o conceito que descreve o ato de um objeto poder assumir
      diferentes formas
    </h4>
    <h4>
      Na OOP/POO, isso pode ser percebido na
      <strong>"sobrescrita de métodos"</strong>
    </h4>
    <h4>
      No javaScript, uma classe filha pode ter as suas próprias implementações
      dos métodos da classe mãe. A isso damos o nome de
      <strong>"sobrescrita de métodos"</strong>
    </h4>
    <br />
    <h3>Exemplo:</h3>
    <h4>A classe Vehicle possui alguns atributos e um método move()</h4>
    <h4>
      As classes Bike, Car, Ship and Plane, todas são filhas da classe Vehicle,
      mas cada uma dessas filhas implementa o método move() de maneira diferente
      (sobrescrevendo o método)
    </h4>
    <br />
    <h3>Vamos ver na pratica</h3>
    <h3>
      Criamos uma pasta com o nome "polimorfismo", com o ficheiro "index.js"
    </h3>
    <h3>Dentro desse ficheiro, criamos uma classe Vehicle: class Vehicle{}</h3>
    <h4>class Vehicle{}</h4>
    <h3>
      Dentro dessa classe, não precisámos de atributos, então escrevemos ja o
      método move() sem parâmetros, com uma mensagem na consola `O veículo esá a
      mover-se`
    </h3>
    <h4>move(){</h4>
    <h4>console.log(`O veículo esá a mover-se`)</h4>
    <h4>}</h4>
    <h3>
      Agora vamos criar uma classe Car que vai herdar (extends) a classe
      Vehicle.
    </h3>
    <h3>
      Vamos usar o método da classe Vehicle "move()" e vamos mudá-la dentro da
      classe Car
    </h3>
    <h4>classe Car extends Vehicle{</h4>
    <h4>move(speed){</h4>
    <h4>console.log(`O carro está a mover-se a ${speed} km/h`)</h4>
    <h3>
      Agora vamos criar uma classe Bike que vai herdar (extends) a classe
      Vehicle.
    </h3>
    <h3>
      Vamos usar o método da classe Vehicle "move()" e vamos mudá-la dentro da
      classe Bike
    </h3>
    <h4>classe Bike extends Vehicle{</h4>
    <h4>move(speed){</h4>
    <h4>console.log(`A bicicleta está a mover-se a ${speed} km/h`)</h4>
    <h3>
      Vamos criar uma classe Ship que vai herdar (extends) a classe Vehicle.
    </h3>
    <h3>
      Vamos usar o método da classe Vehicle "move()" e vamos mudá-lo dentro da
      classe Ship
    </h3>
    <h4>classe Ship extends Vehicle{</h4>
    <h4>move(speed){</h4>
    <h4>console.log(`O navio está a navegar a ${speed}km/h`)</h4>
    <h3>
      Agora vamos criar uma instância de cada uma destas 3 classes: Car, Bike
      and Ship
    </h3>
    <h4>const ferrari = new Car()</h4>
    <h4>const titanic = new Ship()</h4>
    <h4>const ktm = new Bike()</h4>
    <h3>Agora vamos usar o mesmo método nestas 3 instâncias</h3>
    <h4>ferrari.move(280)</h4>
    <h4>titanic.move(39)</h4>
    <h4>ktm.move(20)</h4>
    <h3>Executamos com o node e vemos o resultado: node index.js</h3>
    <br />
    <h3>
      Vamos criar uma função start, que vai receber como parâmetro um veículo
      qualquer, vai escrever uma mensagem na consola a dizer "A iniciar um
      veículo..." e executar o método move() para vermos a mensagem diferente em
      cada veículo
    </h3>
    <h4>function start(vehicle){</h4>
    <h4>console.log("A iniciar um veículo..."</h4>
    <h4>vehicle.move()</h4>
    <h4>}</h4>
    <h3>Executamos a função:</h3>
    <h4>start(ferrari)</h4>
    <h4>start(titanic)</h4>
    <h4>start(ktm)</h4>
    <br />
    <hr />
    <br />
    <h1>Acessores: get e set</h1>
    <br />
    <h4>
      Os acessores são um recurso para definir a forma de como acedemos a uma
      propriedade de um objeto:
    </h4>
    <p>Conseguir ler o nome do objeto pessoa: pessoa.nome -> GET</p>
    <p>
      Conseguir configurar o nome do objeto pessoa: pessoa.nome = "Cunha" -> SET
    </p>
    <h4>
      Com o acessor <strong>"get"</strong> podemos modificar a forma como uma
      propriedade é lida
    </h4>
    <h4>
      Com o acessor <strong>"set"</strong> podemos modificar a forma como uma
      propriedade é alterada via atribuição
    </h4>
    <h4>
      Também conhecidos como <strong>"getters"</strong> and
      <strong>"setters"</strong>
    </h4>
    <br />
    <h3>exemplos:</h3>
    <h4>
      Uma classe possui uma propriedade que necessita de uma verificação antes
      de ter o seu valor modificado
    </h4>
    <h4>
      Uma classe possui uma propriedade privada que necessita de um acessor
      público só de leitura
    </h4>
    <br />
    <h3>Exemplo na pratica</h3>
    <h3>GET</h3>
    <h4>
      Vamos criar uma pasta com o nome "Get and Set", dentro dessa pasta criamos
      um ficheiro com o nome "getSet.js"
    </h4>
    <h4>
      Dentro desse ficheiro criamos a classe "Wallet"; dentro dessa classe vamos
      criar um atributo privado chamado "amount"; No construtor vamos dizer que
      o nosso amount começa num valor fixo (109.99) e queremos que seja um
      numero inteiro, então vamos multiplica-lo por 100; //Isto vai ser salvo
      COMO 10999, SEM VIRGULAS/PONTOS, só para criarmos uma "regra" que faça com
      que guarde sempre um numero inteiro;
    </h4>
    <h4>class Wallet{</h4>
    <h4>#amount</h4>
    <h4>constructor(){</h4>
    <h4>
      this.#amount = 109.99 * 100 //Isto vai ser salvo assim 10999, SEM
      VIRGULAS/PONTOS, só para criarmos uma "regra" que faça com que guarde
      sempre num numero inteiro
    </h4>
    <h4>}</h4>
    <h3>Agora vamos usamos o get como se usassemos uma função:</h3>
    <h3>
      escrevemos get (palavra reservada do JS), definimos um nome para o nosso
      get, agora precisamos de colocar parentisis como se fosse um método normal
      () e abrir chavetas: get amount(){}
    </h3>
    <h3>
      Dentro das chavetas conseguimos fazer o que quisermos, um determinado
      comportamento ou operação; Neste caso só queremos que retorne o valor que
      está na propriedade privada: return this.#amount; Mas não podemos só
      retornar o this.#amount porque se fizermos isso vem neste numero: 10999;
      Nós queremos que esse numero seja só para guardar MAS queremos que o user
      veja o numero normalmente (109.99), então temos que dividir o this.#amount
      por 100
    </h3>
    <h4>get amount(){</h4>
    <h4>return this.#amount / 100</h4>
    <h4>}</h4>
    <h3>
      Então agora vamos criar uma instância da classe Wallet e dar console.log
      no amount dessa instância
    </h3>
    <h3>
      com o get, nós não precisamos de usar o amount como se fosse um metodo com
      o: xWallet.amount(); Com o get é so: xWallet.amount
    </h3>
    <h4>const myWallet = new Wallet()</h4>
    <h4>console.log(myWallet.amount)</h4>
    <br />
    <h3>SET</h3>
    <h3>Vamos criar uma propriedade privada chamada username: #username</h3>
    <h4>#username</h4>
    <h3>Agora usamos o SET também como se fosse uma função:</h3>
    <h3>
      escrevemos set (palavra reservada do JS), definimos um nome para o nosso
      set "username", agora precisamos de colocar um parâmetro "newUsername"(vai
      ser o que o utilizador vai escrever depois do sinal de igual), e abrir
      chavetas: set username(newUsername){};
    </h3>
    <h3>
      Dentro do set, vamos conseguir trocar o seu valor: this.username =
      newUsername
    </h3>
    <h4>set username(newUsername){</h4>
    <h4>this.#username = newUsername</h4>
    <h3>
      Agora vamos criar um get para podermos ler e ver o valor desse username
      (desta vez sem nenhuma regra)
    </h3>
    <h4>get username(){</h4>
    <h4>return this.#username</h4>
    <br />
    <h3>Agora para utilizarmos o set que fizemos é so:</h3>
    <h4>myWallet.username= "Cunha"</h4>
    <h4>console.log(myWallet.username)</h4>
    <br />
    <h3>Basicamente o get e set funcionam desta maneira...</h3>
    <h3>
      Podemos utiliza-los para proteger os nossos atributos privados e para
      modificar o comportamento de atribuição de leitura de uma propriedade.
    </h3>
    <h3>
      A diferença entre o get e set dos métodos normais é que nós conseguimos
      manipula-los como se fosse um atributo; Ou seja, é como se fosse um método
      mas nós conseguimos utilizar o sinal de =; Ex:
    </h3>
    <h4>myWallet.username += "Dev"</h4>
    <h4>console.log(myWallet.username)</h4>
    <br />
    <h3>
      Agora vamos aplicar a regra de validação no SET, para vermos como
      conseguimos modificar o comportamento dele
    </h3>
    <h3>Dentro do set:</h3>
    <h4>if(typeof newUsername === "string"){</h4>
    <h4>this.#username = newUsername</h4>
    <h4>}else{</h4>
    <h4>console.log("Username must be of type string")</h4>
    <h4></h4>
    <h4>}</h4>
    <h3>
      Agora o username do myWallet só aceita um valor string, se não for string
      dá erro!
    </h3>
    <h4>myWallet.username = 10</h4>
    <h4>myWallet.username = True</h4>
    <h4>myWallet.username = "Claudio Cunha"</h4>
    <br />
    <hr />
    <br />
    <h1>Atributos e Métodos Estáticos</h1>
    <br />
    <h4>
      São atributos e métodos definidos numa classe que não dependem de uma
      instância para serem utilizados
    </h4>
    <h4>São acedidos diretamente pela classe ao invés de pela instância</h4>
    <h3>Exemplos:</h3>
    <h4>
      Uma classe precisa definir um atributo que seja global, ou seja, que tenha
      o mesmo valor para todas as instâncias
    </h4>
    <h4>
      Uma classe de modelo para uma tabela no banco de dados onde os métodos
      devem estar disponíveis mesmo que nenhuma instância tenha sido carregada
      ainda
    </h4>
    <h3>Vamos ver exemplos na pratica:</h3>
    <h3>
      Criamos uma pasta chamada "static" com um arquivo chamado "Reservation",
      dentro dele criamos a sua classe "Reservation"; Criamos um constructor com
      parâmetros: "guests", "room","days"; Dentro do constructor vamos colocar
      os seus atributos; E queremos que haja um total que multiplique os dias
      que o hospede vai ficar no quarto pela taxa diária do hotel
    </h3>
    <h4>class Reservation{</h4>
    <h4>constructor(guests, room, days){</h4>
    <h4>this.guests = guests</h4>
    <h4>this.room = room</h4>
    <h4>this.days = days</h4>
    <h4>
      this.total = days * Reservation.baseFee (baseFee é atributoEstático que
      vamos criar)
    </h4>
    <h3>Vamos criar essa taxa(baseFee)</h3>
    <h3>
      É para estas coisas que servem os Atributos e Métodos Estáticos: São
      valores fixos que não se alteram
    </h3>
    <h3>
      Para criar um atributo estático, usamos a palavra reservada do javaScript
      "static"; então vamos dizer que a taxa estática desta classe de Reservas é
      de 150
    </h3>
    <h4>static baseFee = 150</h4>
    <h3>
      Para aceder a um atributo/método estático, indicamos o
      nomeDaClass.atributoEstático ou nomeDaClass.MétodoEstático:
      Reservation.baseFee // Reservation.MétodoEstático
    </h3>
    <h3>
      Agora vamos criar um método estático que mostre na consola o valor da Base
      Fee que criamos
    </h3>
    <h3>
      Para criar um método estático é exatamente como se fosse um método normal
      mas antes do nome do método, é preciso escrer a palavra reservada do
      javaScript "static"
    </h3>
    <h4>static showBaseFee(){</h4>
    <h4>return console.log(`Base Fee is: ${Reservation.baseFee}`)</h4>
    <h3>
      Agora fora da classe, vamos usar o método que criamos e criar uma reserva:
    </h3>
    <h4>Reservation.showBaseFee()</h4>
    <h4>const res1 = new Reservation(3, "201", 5)</h4>
    <h4>console.log(res1)</h4>
    <h3>Executámos o node e vemos o resultado: node Reservation.js</h3>
    <br />
    <h3>
      Aos atributos e métodos estáticos podemos juntar os Getters and Setters
      (GET and SET)
    </h3>
    <h3>Vamos criar uma taxa Premium para hospedes específicos</h3>
    <h4>static get premiumFee(){</h4>
    <h4>return (Reservation.baseFee = Reservation.baseFee * 1.5)</h4>
    <h4>}</h4>
    <h3>Agora fora da classe, testamos tudo!</h3>
    <h3>
      Acrescentamos depois do 1º teste: console.log do Quarto premium; mudar a
      baseFee para 200 e assim o calculo é feito quando criarmos uma nova
      reserva; Criar nova reserva; console.log a mostrar o Premium Fee;
      console.log da segunda reserva;
    </h3>
    <h4>console.log("Quarto premium");</h4>
    <h4>Reservation.baseFee = 200;</h4>
    <h4>const res2 = new Reservation(2, "504", 5);</h4>
    <h4>console.log(`Premium fee is: ${Reservation.premiumFee}€`)</h4>
    <h4>console.log(res2);</h4>
    <br />
    <hr />
    <br />
  </body>
</html>
