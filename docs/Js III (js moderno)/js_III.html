<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS-III (js moderno)</title>
  </head>
  <body>
    <h1>Template literals</h1>
    <p>
      Serve para escrevermos codigo Js numa variavel, sem precisar de interpolar
      (+) tudo.
    </p>
    <p>usamos o Template literals assim:</p>
    <p>
      ` podemos escrever o que quisermos e juntar uma variavel ou codigo js:
      ${codigoJs/variavel} `
    </p>
    <h3>Por ex:</h3>
    <h3>Ficheiro Script</h3>
    <p>const name = "Cunha";</p>
    <p>console.log(`Hello, ${name}</p>
    <p>We're in ${Date()}</p>
    <p>2+2=${2 + 2}`);</p>
    <br />
    <hr />
    <br />
    <h1>Arrow functions</h1>
    <p>Uma forma de escrevermos funções anônimas</p>
    <p>Não escrevemos a palavra "function", utilizamos => após os parâmetros</p>
    <p>Não possui as propriedades: this, arguments, super e new.target</p>
    <p>
      também permite retornar diretamente uma expressão, caso seja uma função de
      uma unica linha
    </p>
    <p>exemplo:</p>
    <p>const sum = (a,b) =>{</p>
    <p>return a+b</p>
    <p>}</p>
    <br />
    <p>Outro exemplo:</p>
    <p>const multiply = (a,b) => a*b</p>
    <br />
    <h3>Ficheiro js</h3>
    <br />
    <p>function normalSum(a, b) {</p>
    <p>return a + b;</p>
    <p>}</p>
    <p>console.log(`Soma normal: ${normalSum(5, 12)}`);</p>
    <p>const anonymousSum = function (a, b) {</p>
    <p>return a + b;</p>
    <p>};</p>
    <p>console.log(`Soma anônima: ${anonymousSum(5, 12)}`);</p>
    <p>const arrowSum = (a, b) => {</p>
    <p>return a + b;</p>
    <p>};</p>
    <p>console.log(`Soma Arrow: ${arrowSum(5, 12)}`);</p>
    <p>const arrowLine = (a, b) => a + b;</p>
    <p>console.log(`Soma ArrowLine: ${arrowLine(5, 12)}`);</p>
    <p>const towns = ["Porto", "Lisboa", "Porto-Covo", "asdasd", "lorem"];</p>
    <p>const startingWithP = towns.filter((town) => town[0] === "P");</p>
    <p>console.log(startingWithP);</p>
    <br />
    <hr />
    <br />
    <h1>Desestruturação de objetos e arrays</h1>
    <br />
    <p>
      Funcionalidade que permite criar variaveis a partir de propriedades de um
      objeto ou elementos de um array
    </p>
    <p>
      No caso das propriedades do objeto, as variaveis serão criadas com mesmo
      nome da propriedade
    </p>
    <p>
      No caso dos elementos do array, podemos atribuir qualquer nome para a
      variável
    </p>
    <p>
      Também pode ser utilizada de outras formas, como nos parâmetros de uma
      função
    </p>
    <p>ex:</p>
    <p>const {name,email}=person</p>
    <p>const [x,y]= coordinates</p>
    <p>function hello({name}) {</p>
    <p>console.log(`Hello, ${name}`)</p>
    <p>}</p>
    <br />
    <h3>Ficheiro Js</h3>
    <br />
    <p>const person = {</p>
    <p>name: "Luke",</p>
    <p>job: "Farmer",</p>
    <p>parents: ["Anakin", "Padme"],</p>
    <p>};</p>
    <p>const name = person.name;</p>
    <p>const { job, parents } = person;</p>
    <p>console.log(name, job, parents);</p>
    <p>const [father, mother] = parents;</p>
    <p>console.log(father, mother);</p>
    <p>function createUser(person) {</p>
    <p>const id = Math.floor(Math.random() * 999);</p>
    <p>return {</p>
    <p>id,</p>
    <p>name: person.name,</p>
    <p>job: person.job,</p>
    <p>parents: person.parents,</p>
    <p>};</p>
    <p>}</p>
    <p>const luke = createUser(person);</p>
    <p>console.log(luke);</p>
    <p>const person2 = {</p>
    <p>name: "Alice",</p>
    <p>job: "Farmer",</p>
    <p>parents: ["Jonh", "Marie"],</p>
    <p>};</p>
    <p>function createUser2({ name, job, parents }) {</p>
    <p>const id = Math.floor(Math.random() * 999);</p>
    <p>return {</p>
    <p>id,</p>
    <p>name,</p>
    <p>job,</p>
    <p>parents,</p>
    <p>};</p>
    <p>}</p>
    <p>const alice = createUser2(person2);</p>
    <p>console.log(alice);</p>
    <br />
    <hr />
    <br />
    <h1>Operador spread</h1>
    <br />
    <p>
      Operador spread (espalhar), serve para espalhar os elementos de um objeto
      iteravel, como um array ou uma string.
    </p>
    <p>Utilizamos o spread, desta maneira:</p>
    <p>let str = "Hello, World"</p>
    <p>let arr = [4,2,8,3,1]</p>
    <p>console.log(...str) // separa as letras: H E L L O , W O R L D</p>
    <p>consolelog(...arr) // separa os elementos: 4 2 8 3 1</p>
    <h4>Com o operador spread, podemos:</h4>
    <h4>Passar vários parâmetros de uma unica vez</h4>
    <h4>Clonar objetos iteráveis</h4>
    <h4>
      Copiar um array/objeto, conseguindo fazer manipulações sem afetar o
      array/objeto original
    </h4>
    <h4>Transformar strings em arrays</h4>
    <br />
    <h3>Ficheiro js:</h3>
    <br />
    <p>
      const towns = ["Prontera", "Izlude", "Payon", "Alberta", "Geffen",
      "Morroc"];
    </p>
    <p>console.log(towns);</p>
    <p>console.log(...towns);</p>
    <p>console.log(...towns[0]);</p>
    <p>const townsCopy = towns;</p>
    <p>townsCopy.pop();</p>
    <p>townsCopy.pop();</p>
    <p>townsCopy.push("Porto");</p>
    <p>console.log({ towns, townsCopy });</p>
    <p>const townsClone = [...towns];</p>
    <p>townsClone.push("Lisbon");</p>
    <p>console.log({ towns, townsCopy, townsClone });</p>
    <p>const townsObj = { ...towns };</p>
    <p>const townsObjClone = { ...townsObj };</p>
    <p>townsObjClone.test = "CloneCloneClone";</p>
    <p>console.log({ townsObj, townsObjClone });</p>
    <br />
    <hr />
    <br />
    <h1>Rest params</h1>
    <br />
    <p>
      É uma técnica que permite a uma função receber qualquer número de
      parâmetros
    </p>
    <p>
      Também permite manipular esses parâmetros como um array na definição da
      função (o que diferencia do objeto arguments)
    </p>
    <br />
    <h3>ex:</h3>
    <h3>Ficheiro JS</h3>
    <h4>function sum(...numbers){</h4>
    <h4>return numbers.reduce((accum,num) => accum + num, 0)</h4>
    <h4>console.log(sum(2, 2));</h4>
    <h4>console.log(sum(2, 2, 2, 2, 2, 2, 2));</h4>
    <h4>console.log(sum(32, 24, 55, 57, 41, 39, 12, 6));</h4>
    <br />
    <hr />
    <br />
    <h1>Encadeamento opcional (optional chaining)</h1>
    <br />
    <p>
      Operador que permite ler propriedades internas de uma cadeia de objetos
      sem que a validação de cada referência da cadeia seja realizada
    </p>
    <p>
      Por outras palavras, permite aceder propriedades internas sem lançar erros
      quando uma propriedade é nullish (null ou undefined)
    </p>
    <p>
      Funciona de forma similar ao encadeamento normal, (operador "."), porém é
      escrito com "?."
    </p>
    <p>encadeamento normal: console.log</p>
    <p>encadeamento opcional: console?log</p>
    <h3>ex:</h3>
    <h3>Ficheiro JS</h3>
    <br />
    <p>const user = {</p>
    <p>name: "John Doe",</p>
    <p>email: "doejohn@email.com",</p>
    <p>friends: [</p>
    <p>{</p>
    <p>name: "Marry",</p>
    <p>address: {</p>
    <p>street: "Some Street",</p>
    <p>number: 77,</p>
    <p>},</p>
    <p>},</p>
    <p>],</p>
    <p>age: 42,</p>
    <p>phone: {</p>
    <p>countryCode: "+55",</p>
    <p>ddd: "22",</p>
    <p>number: "998765432",</p>
    <p>},</p>
    <p>};</p>
    <p>
      console.log(user.friends[0]?.phone?.ddd); //Isto é igual a undefined (mas
      não dá erro)
    </p>
    <p>
      //console.log(user.friends[0].phone.ddd); //Isto é igual a erro: Uncaught
      TypeError: Cannot read properties of undefined (reading 'ddd')
    </p>
    <p>
      console.log(user?.brothers?.name); //Mesmo que as coisas não existam, não
      há erros na consola
    </p>
    <p>
      //console.log(user.brothers.name); //Podemos ver que aqui também vai dar
      erro: Uncaught TypeError: Cannot read properties of undefined (reading
      'name')
    </p>
    <p>
      //Basicamente o ?. serve para ler o que está atras e se não existir, ele
      diz-nos undefined e que não consegue ler o que está à frente...
    </p>
    <p>//Outro ex:</p>
    <p>console.log(user.brothers?.[5].name); //Isto é igual a undefined</p>
    <p>
      //console.log(user.brothers[5].name); //Isto dá erro e diz que não
      consegue ler o [5], porque o brothers não existe
    </p>
    <br />
    <hr />
    <br />
    <h1>Operador de Coalescência Nula</h1>
    <br />
    <p>
      Operador lógico que retorna o seu operando do lado direito quando o seu
      operador do lado esquerdo é null ou undefined. Caso contrário, ele retorna
      o seu operando do lado esquerdo
    </p>
    <p>Utiliza dois pontos de interrogação "??"</p>
    <p>
      Vale destacar que ele é diferente do operador lógico OU(||), que dá
      curto-circuito em expressões falsy(por exemplo, o numero 0)
    </p>
    <p>
      Pode ser usado para operações lógicas e também para atribuições de valores
      padrão através de short-circuit evaluation (avaliação de curto-circuito)
    </p>
    <p>ex:</p>
    <p>let a = 0</p>
    <p>let c = a || 42 //c será 42</p>
    <p>
      let d = a ?? 42 //d será 0, pois 0 é falsy, mas não nullish (null ou
      undefined)
    </p>
    <p>let e = null ?? 42 //e será 42</p>
    <br />
    <h4>Outro ex com explicação:</h4>
    <br />
    <p>const a = 0; //false</p>
    <p>const b = null; //false</p>
    <p>const c = "teste"; //true</p>
    <p>console.log(a || b || c);</p>
    <p>const a2 = 0; //false and not null/undefined</p>
    <p>const b2 = null; //false and null</p>
    <p>const c2 = "teste2"; //true and not null/undefined</p>
    <p>console.log(a ?? b ?? c);</p>
    <br />
    <hr />
    <br />
    <h1>Introdução aos módulos</h1>
    <br />
    <p>Já vimos como incluir código javascript diretamente no html:</p>
    <p>Com a tag script</p>
    <p>
      À medida que os sites evoluíram e as aplicações web começaram a surgir, o
      javascript foi cada vez mais utilizado.
    </p>
    <p>
      Além disso, o uso do javascript fora dos navegadores também passou a ser
      não apenas possível, como muito popular:
    </p>
    <p>
      Node.js tecnologia que permite interpretar código javascript fora do
      navegador, foi criado em 2009
    </p>
    <p>
      Isto tudo contribuiu para o amadurecimento do javascript e a implementação
      de uma funcionalidade já existente em outras linguagens: módulos
    </p>
    <br />
    <br />
    <p>O que são módulos?</p>
    <br />
    <p>Pensa em capítulos de um livro, ou secções de um supermercado</p>
    <p>Os autores organizam as suas histórias em capítulos.</p>
    <p>Supermercados organizam os seus produtos em secções.</p>
    <p>Bons programadores organizam os seus códigos em módulos</p>
    <p>
      Módulos são grupos de codigos agrupados com funcionalidades distintas que
      podem ser partilhados, adicionados ou removidos dos nossos softwares
    </p>
    <br />
    <p>O porquê de usar módulos:</p>
    <p>Facilidade de dar Manutenção</p>
    <p>
      Namespacing: Para evitar conflitos, porque podemos ter um modulo A com a
      função x dentro; e um modulo B com a função x dentro. Sendo as funções
      completamente diferentes! Não entram em conflito mesmo com o mesmo nome
    </p>
    <p>Facilidade de Reutilizar</p>
    <br />
    <br />
    <p>Módulos no javascript:</p>
    <p>CommonJS</p>
    <p>ES Modules (EcmaScript)</p>
    <br />
    <hr />
    <br />
    <h1>Módulos CommonJS</h1>
    <h4>Só funcionam com o node, não funciona com o browser.</h4>
    <br />
    <h3>
      Podemos ter varios ficheiros js: Vamos usar como exemplo 2 ficheiros--
      x.js; ficheiro.js
    </h3>
    <h3>No ficheiro principal (normalmente: script.js / index.js):</h3>
    <h3>
      importámos o ficheiro.js com: const ficheiro =
      require(./caminhoDoFicheiro/ficheiro.js)
    </h3>
    <h3>importámos o x.js com: const x = require(./caminhoDoX/x.js)</h3>
    <h3>
      No ficheiro.js, para que a importação seja possivel, fazemos:
      module.exports = ficheiro
    </h3>
    <h3>
      No x.js, para que a importação seja possivel, fazemos: module.exports = x
    </h3>
    <br />
    <hr />
    <br />
    <h1>ES Modules</h1>
    <h4>Já funciona com o browser.</h4>
    <br />
    <h3>
      Num ficheiro js separado do principal (script.js / index.js), podemos ter
      várias funções
    </h3>
    <h3>
      Vamos dizer que o ficheiro secundário se chama: functions.js e tem muitas
      funções dentro deles
    </h3>
    <h3>
      Para permitirmos uma importação destas funções noutro ficheiro: Antes de
      cada função dentro do ficheiro functions.js, escrevemos: export
    </h3>
    <h3>ex: export function hw(){</h3>
    <h3>console.log("Hello World!")}</h3>
    <br />
    <h3>
      Agora para importarmos essa função no ficheiro principal (index.js /
      script.js) fazemos: import {hw} from "./functions.js"
    </h3>
    <h3>
      Para usarmos essa função no ficheiro principal, é so: console.log(hw())
    </h3>
    <br />
    <h3>
      Só com isto ainda vamos ter um erro, para corrigir esse erro, precisamos
      de ir ao nosso ficheiro HTML e no script escrever: type="module"
    </h3>
    <h3>ex: script src="script.js" type="module" script</h3>
    <br />
    <hr />
    <br />
    <h1>Tipos de export do ESM</h1>
    <br />
    <h3>
      Para não usarmos sempre o "export" em linha, nas funções, fazemos isto:
    </h3>
    <br />
    <h3>Criámos um ficheiro para as funções: funcoes.js e:</h3>
    <br />
    <p>function group() {</p>
    <p>console.log("Export nomeado não-inline (agrupado)");</p>
    <p>}</p>
    <p>function a() {</p>
    <p>alert("função A");</p>
    <p>}</p>
    <p>function b() {}</p>
    <p>function c() {}</p>
    <p>function d() {}</p>
    <p>function exportDefault() {</p>
    <p>console.log("Export default não-inline");</p>
    <p>}</p>
    <p>export { group, a, b, c, d };</p>
    <br />
    <h3>Criamos um ficheiro principal: script.js e:</h3>
    <br />
    <p>import { inline } from "./funcoes.js";</p>
    <p>import exportDefault, { group, a, b, c, d } from "./funcoes.js";</p>
    <p>inline();</p>
    <p>defaultInline();</p>
    <p>group();</p>
    <p>a();</p>
    <p>exportDefault();</p>
    <br />
    <hr />
    <br />
    <h1>Conhecer o NPM</h1>
    <h3>O que é:</h3>
    <h4>
      npm, ou node package manager, é um gerenciador de pacotes do Node.js
    </h4>
    <h4>
      OBS: Node.js é a ferraenta que h4rmite executar o javascript fora do
      browser
    </h4>
    <br />
    <h3>Para que serve:</h3>
    <h4>
      Com o npm, os programadores podem partilhar os seus módulos com outros
    </h4>
    <h4>
      O npm é um conjunto de ferramentas que permite partilhar os módulos na
      internet, transferir módulos para o nosso proprio projeto e gerir os
      módulos instalados no nosso projeto
    </h4>
    <h4>
      Isto tudo aliado ao poder da comunidade open-source permite aumentar a
      nossa produtividade (princípio DRY, Don't Repeat Yourself)
    </h4>
    <br />
    <h3>O npm também pode ser visto como 3 recursos que trabalham juntos:</h3>
    <h4>1º Uma ferramenta de linha de comando para executar o nom</h4>
    <h4>
      2º Um repositório online de pacotes, onde ficam guardados os módulos que
      podemos tranferir
    </h4>
    <h4>
      3º O site <a href="https://npmjs.com">https://npmjs.com</a> é onde podemos
      navegar pelos módulos existentes no repositório
    </h4>
    <br />
    <hr />
    <br />
    <h1>Usar o npm</h1>
    <br />
    <h3>Instalar o node:</h3>
    <h4>
      No Windows a maneira mais fácil de instalar o npm é através do site
      https://nodejs.org, dowload da versão LTS (versão mais estável, menos
      sujeita a bugs e falhas de segurança)
    </h4>
    <br />
    <h4>
      No Linux podes instalar o Node e o npm utilizando o gerenciador de pacotes
      da sua distribuição (apt para Debian/Ubuntu, yum para Fedora, pacman para
      Arch, etc)
    </h4>
    <h4>
      No Linux também é possível usar o asdf, um gerenciador de versões, para
      instalar o Node e o npm. Passo a passo da instalação:
      https://asdf-vm.com/guide/getting-started.html
    </h4>
    <p>
      Atenção! Se utilizas o WSL deves instalar o Node e o npm dentro da sua
      distribuição Linux do WSL, seguindo o método de instalação para Linux
    </p>
    <br />
    <h3>
      Uma vez que tenhas o npm instalado, vamos começar a utilizá-lo abrimos a
      linha de comando e testamos a instalação. Executa o comando abaixo e ele
      deverá retornar a versão do npm:
    </h3>
    <br />
    <h4>Ver se está instalado: npm --version</h4>
    <br />
    <h4>
      Agora já podemos criar um projeto gerenciado pelo npm com o seguinte
      comando: npm init
    </h4>
    <p>
      Obs.: foi criado o arquivo “package.json”, um arquivo com informações do
      nosso projeto.
    </p>
    <br />
    <h4>
      Para instalar um novo módulo no nosso projeto usamos o comando: npm
      install --save lodash
    </h4>
    <br />
    <h4>
      Já podemos criar um arquivo "script.js”, importar o módulo lodash e
      utilizá-lo:
    </h4>
    <p>const _ = require("lodash")</p>
    <p>console.log(_.isArray([]))</p>
    <p>console.log(_.kebabCase("Cláudio Cunha"))</p>
    <br />
    <h3>Corremos o ficheiro (no terminal): node script.js</h3>
    <h4>
      Outra funcionalidade importante é a instalação de dependências de
      desenvolvimento, o que pode ser feito com a flag: npm install --save-dev
      eslint
    </h4>
    <p>
      Obs.: Uma dependência de desenvolvimento é um módulo que o nosso projeto
      só utiliza enquanto o estamos a codificar
    </p>
    <br />
    <h4>
      Um último recurso interessante para mencionar nesta introdução são as
      dependências globais. Uma dependência global é um módulo que não fica
      vinculado a um projeto específico, mas é instalado no computador para
      usarmos onde e quando quiser. Para instalar um módulo globalmente usamos o
      comando com a flag: npm install --global sass
    </h4>
    <br />
    <h4>
      E por fim, também podemos remover módulos manualmente excluindo-os do
      arquivo “package.json” ou usando o comando: npm uninstall eslint
    </h4>
    <br />
    <hr />
    <br />
    <h1>Json</h1>
    <br />
    <h4>
      JSON, ou JavaScript Object Notation, é um
      <strong>formato de arquivo</strong> utilizado para troca de dados
    </h4>
    <h4>
      É um formato compacto, representado em texto, de padrão aberto e que
      trabalha utilizando o sistema de chave-valor
    </h4>
    <h4>
      Como o próprio nome diz, ele utiliza a mesma notação, ou seja, forma de se
      escrever o conteúdo, dos <strong>objetos do javascript</strong>(com alguns
      mínimos detalhes diferentes)
    </h4>
    <h4>
      É muito utilizado para troca de dados entre diferentes sistemas e em
      arquivos de configuração no javascript
    </h4>
    <h4>
      É amplamente utilizado na web e é suportado por várias linguagens além do
      javascript
    </h4>
    <br />
    <h3>Manipular arquivos JSON no javascript:</h3>
    <br />
    <h4>JSON.parse() //converte ua string para objeto json-compatible</h4>
    <h4>JSON.stringify() //converte um objeto json-compatible para string</h4>
    <br />
    <hr />
    <br />
    <h1>npx e scripts npm</h1>
    <br />
    <h3>Criamos uma pasta e:</h3>
    <h4>No terminal (pode ser no vscode) escrevemos:</h4>
    <h4>npm init -y</h4>
    <p>
      NPX: Comando que utilizamos para executar as bibliotecas(pacotes) que
      instalarmos pela linha de comando
    </p>
    <h4>npm install --save hello-world-npm</h4>
    <br />
    <h3>
      Nem todas as bibliotecas(pacotes) vão ter executáveis, para vermos se há
      ficheiros executáveis ou não:
    </h3>
    <h4>- Ver a documentação (obviamente)</h4>
    <h4>
      - Abrir a pasta [node_moduloes] -> .bin -> podemos ver que temos um
      atalho: hello-world-npm
    </h4>
    <br />
    <h3>Para executarmos isto:</h3>
    <h4>npx hello-world-npm</h4>
    <br />
    <h4>
      No ficheiro: package.json, na parte dos "scripts" criamos uma chave
      "hello" com "npx hellow-world-npm"
    </h4>
    <h4>npm run hello</h4>
    <p>
      Dica: Nos scripts não precisamos de usar a palavra "npx", pois já é
      sub-entendida pelo node
    </p>
    <h4>
      Ou seja: no ficheiro "package.json", na parte dos "scripts", criamos a
      chave "hello" com o valor "hellow-world-npm
    </h4>
    <br />
    <h4>Tambem podemos executar uma própria função nestes "scripts"</h4>
    <h3>Vamos criar um ficheiro: script.js</h3>
    <h3>Dentro desse ficheiro:</h3>
    <h4>const hello = require("hello-world-npm");</h4>
    <h4>
      console.log(`Isto é um exemplo de uma função num script: ${hello()}`);
    </h4>
    <h4>
      Agora para corrermos isto, sem colocar a função nos "scripts": node
      script.js
    </h4>
    <h4>
      No ficheiro "package.json", nos "scripts" adicionamos uma chave
      "start"(nome específico do npm para inciar) e o valor : "node script.js"
    </h4>
    <h4>Agora fazemos: npm run start</h4>
    <p>
      Como o valor da chave "start" é específico do npm, nós para correr isto só
      precisamos de fazer: npm start
    </p>
    <br />
    <hr />
    <br />
    <h1>Conhecer o babel</h1>
    <br />
    <h4>Babel é um compilador JavaScript</h4>
    <h4>
      Um compilador é uma ferramenta que permite converter o código escrito numa
      linguagem para outra linguagem
    </h4>
    <h4>
      O babel é um conjunto de ferramentas que serve principalmente para
      converter código nas versões mais recentes do javascript para código de
      versões mais antigas, a fim de torná-lo compativel com plataformas que não
      suportam as versões mais novas
    </h4>
    <br />
    <h3>Alguns recursos do Babel:</h3>
    <h4>Transformação da sintaxe</h4>
    <h4>Polyfill de recursos não existentes no ambiente alvo</h4>
    <h4>Transformação de código</h4>
    <h4>E muito mais...</h4>
    <h4>
      Mais informações sobre:
      <a href="https://babeljs.io/">https://babeljs.io/</a>
    </h4>
    <br />
    <p>Usamos o babel assim:</p>
    <p>Criamos uma pasta, entramos no terminal dessa pasta</p>
    <p>
      npm install --save-dev //instalação de dependências de desenvolvimento
    </p>
    <p>npm install -D //instalação de dependências de desenvolvimento</p>
    <p>O babel é composto por 2 pacotes principais:</p>
    <p>@babel/core //nucleo do babel, é o que compila o codigo etc etc</p>
    <p>
      @babel/cli //ferramenta de linha de comando do babel, com ele interagimos
      com o babel core através do terminal
    </p>
    <br />
    <p>
      Tambem existe o: @babel/preset-env //É um pacote que vai configurar
      automaticamente o babel para nós, configuração "preset" pre-definida
    </p>
    <p>
      Então vamos instalar esses 3: npm install --save-dev @babel/core
      @babel/cli @babel/preset-env
    </p>
    <p>
      Agora ja podemos começar a utilizar, vamos criar um arquivo com o nome:
      index.js e copiar o exercicio "1 Estatística na programação" deste modulo
    </p>
    <p>
      Exercicio onde temos Arrow Functions, alguns metodos, Rest Params, etc
    </p>
    <p>npx babel index.js</p>
    <p>
      Mostra no terminal todo o conteúdo que temos, com algumas correções como
      por ex: O uso do ; no fim de cada linha
    </p>
    <p>
      Mas no terminal fica um bocado inutil, podemos passar esse codigo
      corrigido diretamente para um ficheiro, com a flag: npx babel index.js
      --out-file dist.js
    </p>
    <p>
      Mas o código ainda não foi compilado porque não utilizamos o preset-env
      ainda, para compilar: npx babel index.js --outfile dist.js
      --presets=@babel/preset-env
    </p>
    <p>
      Feito isso, o nosso código mudou completamente, podemos ver que há um uso
      do "use strict" que é um recurso que deixa o código melhor e mais seguro,
      as variáveis agora são todas com o var e não com const/let, temos o nosso
      for para substituir o uso do Rest Params, etc
    </p>
    <p>
      Agora, isto é a forma como compilámos o codigo de um ficheiro, mas se
      tivermos vários ficheiros fica um bocado chato fazermos isto... então:
    </p>
    <p>
      Vamos criar uma pasta com o nome "src" (source que significa fonte) e
      colocar o arquivo index.js e criar outro arquivo dentro da pasta, com o
      nome "hello" com o codigo:
    </p>
    <p>const msg = "Hello World"</p>
    <p>console.log(msg)</p>
    <p>
      Agora no terminal, passamos o npx babel com a pasta dos nossos ficheiros
      src com o diretório (outra pasta) dist, codigo:
    </p>
    <p>npx babel src --out-dir dist --presets=@babel/preset-env</p>
    <p>
      Para facilitar estes passos, podemos usar os "scripts" do package.json,
      como falamos antes:
    </p>
    <p>
      No ficheiro "package.json", nos "scripts", adicionamos uma chavel "babel"
      com o valor: "babel src --out-dir dist --presets=@babel/preset-env"
    </p>
    <p>
      Agora no terminal, so precisámos de fazer npm run babel e vai ser feito o
      mesmo procedimento. Podemos apagar a pasta "dist" e testar
    </p>
    <p>
      Até agora fomos utilizando o comando presets=@babel/preset-env, mas o
      babel tem um arquivo de configuração próprio, é so criarmos o arquivo:
      babel.config.js
    </p>
    <p>
      A primeira coisa que o babel faz é procurar se existe esse arquivo de
      configuração
    </p>
    <p>Dentro desse arquvio temos que exportar um objeto: module.exports{</p>
    <p>presets: [</p>
    <p>["@babel/preset-env"]</p>
    <p>]</p>
    <p>Feito isto, não precisamos de usar o:--presets=@babel/preset-env</p>
    <p>
      Basta o: "npm babel src --out-dir dist" ao invés do: npm babel src
      --out-dir dist --presets=@babel/preset-env
    </p>
    <p>
      Para vermos mais sobre as chaves que as configurações do babel podem ter,
      temos que ir à documentação
    </p>
    <br />
    <hr />
    <br />
    <h1>Conhecer o webpack</h1>
    <br />
    <h3>O que é o webpack:</h3>
    <h4>Stack module bundler (empacotador de módulo estático)</h4>
    <h4>
      O objetivo dele é empacotar todos os módulos de uma aplicação a partir de
      um ou mais <strong>pontos de entrada</strong> num ou mais
      <strong>bundles (pacotes)</strong>, que são arquivos estáticos que contêm
      tudo o que a aplicação precisa para funcionar
    </h4>
    <h4>
      O webpack constrói um grafo de dependências para os pontos de entrada, o
      que permite saber exatamente quais módulos são necessários
    </h4>
    <br />
    <h3>funcionamento:</h3>
    <h4>
      o webpack vai buscar todo o conteúdo JavaScript da nossa aplicação e até
      mais do que javascript, junta tudo num pacote que pode ser servido
      estáticamente (arquivo estático é um arquivo que não precisa de ser
      executado/avaliado, simplesmente entregamos o arquivo, como se fizessemos
      download de algo da net... o browser entraga-nos o arquivo que fizemos
      download sem executar nada por trás.
    </h4>
    <h4><a href="https://webpack.js.org">https://webpack.js.org</a></h4>
    <br />
    <h3>Peças chave do webpack:</h3>
    <h4>-Entry:</h4>
    <p>
      Pontos de entrada de onde o webpack procurará por arquivos para empacotar
    </p>
    <h4>-Output:</h4>
    <p>
      A saída resultante do processo de empacotamento dos módulos, ou seja, o
      webpack vai buscar o ponto de entrada e transformar na saída
    </p>
    <h4>Loaders:</h4>
    <p>Por default, o webpack entende apenas javascript e JSON</p>
    <p>
      Loaders permitem que o webpack consiga entender outros tipos de arquivos
      (como .css, por ex), transformando-os em módulos válidos e incluindo-os no
      grafo de dependências
    </p>
    <h4>Plugins:</h4>
    <p>
      São utilizados para estender o comportamento do webpack, realizando
      tarefas mais elaboradas que os loaders (que apenas transformam módulos)
    </p>
    <h3>Porque usar o webpack:</h3>
    <h4>
      Possibilidade de trabalhar com módulos de forma fácil, inclusive módulos
      CommonJS
    </h4>
    <h4>
      Possibilidade de automatizar o gerenciamento dos módulos e dependências da
      aplicação
    </h4>
    <h4>
      Empacotar os módulos em arquivos estáticos permite que sejam servidos na
      web de forma mais fácil e rápida
    </h4>
    <h4>
      Webpack é uma das soluções mais utilizadas do mercado para gerenciamento
      de assets estáticos, sendo utilizado por grandes empresas e frameworks
      populares como Next.js, Vue.js, etc
    </h4>
    <br />
    <h3>Vamos ver na prática</h3>
    <h4>Vamos criar uma pasta com o nome: "15 Usar o webpack"</h4>
    <h4>
      Agora vamos abrir o terminal do vscode nessa pasta e vamos iniciar o npm
      com as respostas do projeto default, para instalarmos as ferramentas que
      vamos precisar: npm init -y
    </h4>
    <h4>
      Agora vamos criar uma pasta com o nome "dist" com o arquivo "index.html"
      com o html default, um titulo e uma ligação a um ficheiro javascript
      "main.js"
    </h4>
    <h4>Criar uma pasta "src" e dentro dela criamos um arquivo "index.js"</h4>
    <h4>
      Instalamos o webpack com uma dependência de desenvolvimento (npm install
      -D), porque o webpack assim como o babel, só é necessário enquanto estámos
      a desenvolver o projeto. Não precisamos de instalar como uma dependência
      (npm install --save). Instalamos tambem 2 pacotes do webpack: o webpack
      ("core" nucleo principal do webpack,faz com que funcione) e o webpack-cli
      (interface de linha de comando, ferramente que deixa executarmos no
      terminal) : npm i -D webpack webpack-cli
    </h4>
    <h4>
      Instalar uma dependência normal (um pacote) como fariamos a desenvolver um
      site ou uma aplicação web: npm i dayjs
    </h4>
    <h4>
      No arquivo "index.js", agora vamos importar o dayjs e dar um alert para
      que mostre o dia de hoje no formato DD/MM/YYY:
    </h4>
    <h4>const dayjs = require("dayjs")</h4>
    <h4>alert(`A data de hoje é: ${dayjs().format("DD/MM/YYYY")}`)</h4>
    <h4>
      Agora vamos utilizar o webpack para empacotar todo o codigo (este index.js
      de exemplo): npx webpack
    </h4>
    <h4>
      Agora na nossa pasta "dist" apareceu o arquivo "main.js" com o codigo
      otimizado, tudo numa linha.
    </h4>
    <h4>
      Agora se apagarmos a pasta node_modules que contem o nosso modulo dayjs,
      vai funcionar tudo na mesma. Porque no arquivo main.js ja está incluido
      tudo o que o nosso codigo precisa para funcionar, assim não precisamos de
      nos preocupar com instalação de dependencias, fazer download no npm dos
      pacotes, etc...
    </h4>
    <br />
    <h3>Configurar o webpack</h3>
    <h4>
      Vamos copiar a pasta em que estamos a trabalhar e mudar de nome para
      "configurar o webpack"
    </h4>
    <h4>
      Na nova pasta (configurar o webpack) vamos trocar o nosso require por um
      import: import dayjs from "dayjs"
    </h4>
    <h4>
      Como apagamos a pasta node_modules, agora vamos ter que a instalar outra
      vez: npm install
    </h4>
    <p>
      Ele vai olhar para o package.json e ver as nossas dependencias e assim
      sabe que pacotes instalar
    </p>
    <h3>Agora vamos configurar o webpack:</h3>
    <h4>
      Nós sabemos que o webpack criou o arquivo "main.js" dentro da pasta "dist"
      sozinho e também identificou que o nosso ficheiro de "entrada" era o
      "index.js".
    </h4>
    <h4>
      Nós conseguimos mudar as opções do webpack para não assumir
      automaticamente isso, com o arquivo default do webpack: webpack.config.js
    </h4>
    <h4>
      Dentro desse arquivo, precisamos de ter um export de um objeto javascript
      (como fizemos no babel) com as configurações que queremos:
    </h4>
    <h4>module.exports = {}</h4>
    <br />
    <h3>Vamos configurar a entrada (entry)</h3>
    <h4>module.exports ={</h4>
    <h4>entry: {</h4>
    <h4>
      index: "./src/index.js" //Assim, conseguimos manualmente específicar a
      "entrada"
    </h4>
    <h4>}</h4>
    <h4>}</h4>
    <h4>Se execurtarmos agora o webpack: npx webpack</h4>
    <h4>
      Foi criado na pasta "dist" um ficheiro "index.js" ao invés do "main.js"
      porque por default, o nome da "saída" é o mesmo da "entrada". Neste caso a
      entrada foi o nome da chave no objeto entry{}.
    </h4>
    <h4>
      Ou seja, se ao invés de-> index: "./src/index.js" escrevermos: date:
      "../src/index.js"
    </h4>
    <h4>
      Assim que executarmos o npx webpack, Vai ser criado o ficheiro "date.js"
    </h4>
    <br />
    <h3>
      Tambem podemos configurar mais opções, vamos configurar a opção que a
      consola está a pedir e a executar por defaul: "mode"
    </h3>
    <h4>Então, no nosso objeto, continuamos:</h4>
    <h4>module.exports = {</h4>
    <h4>entry: {</h4>
    <h4>date: "./src/index.js",</h4>
    <h4>},</h4>
    <h4>
      mode: "development", //Modo development: Com este modo, o webpack não
      deixa o ficheiro otimizado e se formos ver ja não tem só 1 linha com o
      código todo. Este modo serve para conseguirmos ler e análisar melhor qual
      a saída que o webpack está a produzir
    </h4>
    <br />
    <h3>Agora vamos configurar a saída (output)</h3>
    <h4>E para isto vamos importar o modulo "path" do node:</h4>
    <h4>const path = require("path")</h4>
    <h4>
      o modulo path //Vai servir para nos facilitar a escrita dos "caminhos" das
      pastas, com o metodo: resolve()
    </h4>
    <h4>
      resolve() //Serve para calcular o caminho absoluto baseado nos argumentos
      que passarmos: path.resolve()
    </h4>
    <h4>Também tem um argumento que podemos passar em primeiro lugar:</h4>
    <h4>
      __dirname, //Que é o caminho completo para o nosso diretório atual (pasta
      atual): path.resolve(__dirname,)
    </h4>
    <h4>No segundo argumento vamos passar o: "public"</h4>
    <h4>
      "public" //Serve para ficar guardado numa pasta diferente, ou seja, vai
      usar o caminho todo e criar a pasta "public" onde vai ser a nossa saída:
      <br />
      path: path.resolve(__dirname,"public")
    </h4>
    <h4>output: {</h4>
    <h4>path: path.resolve(__dirname,"public")</h4>
    <h4>}</h4>
    <h4>Agora se executarmos o webpack: npx webpack</h4>
    <p>
      Conseguimos ver que foi criada a pasta "public" com o ficheiro "date.js"
      em modo development
    </p>
    <h3>
      Tambem podemos mudar manualmente o nome do arquivo, atraves da chave
      "filename" no output{}
    </h3>
    <h4>filename: "bundle.min.js"</h4>
    <br />
    <h3>
      Agora vamos fazer com que o webpack leia mais arquivos de entrada, porque
      podemos ter varias paginas html com um arquivo de entrada para cada
    </h3>
    <h4>
      Primeiro vamos criar outro arquivo na pasta src com o nome "helloWorld.js"
      com um alert("Hello World")
    </h4>
    <h3>
      Agora no ficheiro webpack.config.js, no objeto "entry:{}", por baixo do
      date:
    </h3>
    <h4>Usamos como chave "hello" com o caminho "./src/hello.js"</h4>
    <h4>hello : "./src/hello.js"</h4>
    <h3>
      Agora a unica coisa que precisámos de estar atentos é ao nome (filename)
      porque não pode ter o mesmo nome (obviamente), para diferenciar cada
      arquivo, fazemos:
    </h3>
    <h4>filename: "./[name]bundle.min.js"</h4>
    <h4>
      Agora vai ser criado um "hello.bundle.min.js" e vamos continuar a ter o
      nosso "bundle.min.js"
    </h4>
    <h4>
      vamos então correr o webpack e ver que foi criado o ficheiro: npx webpack
    </h4>
    <br />
    <h3>O ficheiro "webpack.config.js" ficou:</h3>
    <br />
    <h4>const path = require("path");</h4>
    <h4>module.exports = {</h4>
    <h4>entry: {</h4>
    <h4>date: "./src/index.js",</h4>
    <h4>hello: "./src/helloWorld.js",</h4>
    <h4>},</h4>
    <h4>mode: "development",</h4>
    <h4>output: {</h4>
    <h4>path: path.resolve(__dirname, "public"),</h4>
    <h4>filename: "[name]bundle.min.js",</h4>
    <h4>},</h4>
    <h4>};</h4>
    <br />
    <hr />
    <br />
    <h1>Utilizar loaders</h1>
    <br />
    <p>Vamos copiar a pasta anterior e mudar o nome para "Utilizar loaders"</p>
    <p>Para além disso, vamos:</p>
    <p>-Apagar a pasta "public"</p>
    <p>
      -Dentro do ficheiro do webpack "webpack.config.js", deixámos só o entry
      com a chave index e o seu valor : "./src/index.js", e o mode em modo
      development
    </p>
    <p>-Apagar os ficheiros da pasta "dist" a não ser o "index.html"</p>
    <p>
      -Dentro do ficheiro "index.html", mudamos o src do script que faz ligação
      ao javaScript para index.js ao invés de main.js
    </p>
    <p>Dentro da pasta "src" apagamos o ficheiro helloWorld.js</p>
    <br />
    <h3>Feito isto, proseguimos com a utilização dos loaders</h3>
    <h3>Vamos utilizar os loaders para incluir css nos nossos módulos</h3>
    <h4>
      Estes dois loaders são necessários para incluirmos css a partir do
      webpack:
    </h4>
    <h4>style-loader //Serve para o webpack entender a estilização</h4>
    <h4>
      css-loader //Serve para o webpack conseguir ler os arquivos .css
      específicamente
    </h4>
    <h4>
      npm install -D style-loader css-loader //Instalámos como dependecia de
      desenvolvimento;
    </h4>
    <p>
      Podemos ver agora o arquivo "package.json" e nas "devDependencies" tem o
      style-loader e o css-loader
    </p>
    <h3>Agora que estão os loaders instalados, vamos usá-los</h3>
    <h3>No arquivo do webpack "webpack.config.js":</h3>
    <h4>Passamos mais uma opção (chave), depois do modo (mode): module:{}</h4>
    <h4>
      module:{ //Dentro do module vamos ter outra opção (chave) que vai ser uma
      lista de objetos: rules:[{}]
    </h4>
    <h4>rules : [{}] //Dentro da rules vamos passar algumas propriedades:</h4>
    <h4>
      test: \\Propriedade test é para dizermos ao webpack quais os arquivos que
      queremos que ele execute o loader.
    </h4>
    <h4>
      Para fazer isso utilizámos expressões regulares (forma de analisar/avaliar
      strings): /escrevemosAqui/
    </h4>
    <h4>test: /\.css$/</h4>
    <p>
      O "$" serve para dizermos ao webpack que queremos os ficheiros que tenham
      .css no final do arquivo;
    </p>
    <p>
      A contra barra (\) serve para dizermos que o ponto(.) é mesmo um ponto e
      não outra função. Nas expressões regulares o "." é significa outra coisa
    </p>
    <h4>
      use:[] //Propriedade use é para dizermos ao webpack qual o loader que vai
      usar.
    </h4>
    <p>
      Ou seja, no <strong>test</strong> dizemos quais arquivos é que vamos usar
      o loader; No <strong>use</strong> dizemos quais loaders vamos querer usar
      (os que instalamos)
    </p>
    <h4>use: ["style-loader","css-loader"]</h4>
    <br />
    <h4>O codigo do ficheiro "webpack.config.js" fica:</h4>
    <p>module.exports = {</p>
    <p>entry: {</p>
    <p>index: "./src/index.js",</p>
    <p>},</p>
    <p>mode: "development",</p>
    <p>module: {</p>
    <p>rules: [{</p>
    <p>test: /\.css$/,</p>
    <p>use: ["style-loader", "css-loader"],</p>
    <p>}],</p>
    <p>},</p>
    <p>};</p>
    <br />
    <h3>
      Dentro da pasta "src" Criámos a pasta "styles" com o arquivo "index.css"
      que vai ser o arquivo que vamos incluir na nossa pagina index.html
    </h3>
    <h4>
      Vamos fazer uma estilização simples: cor de fundo escura, cor de texto
      clara (inverter o default da pagina html que tem o fundo claro e o texto
      escuro)
    </h4>
    <p>body{</p>
    <p>background-color: #232323</p>
    <p>color: #fafafa}</p>
    <br />
    <h3>
      Agora para incluir este estilo(css) na nossa página, importamos este
      arquivo css no nosso ponto de entrada (entry); Que é o nosso ficheiro
      index.js"
    </h3>
    <h3>No ficheiro "index.js":</h3>
    <h4>
      import "./styles/index.css" \\importamos o ficheiro css no ficheiro
      javascript
    </h4>
    <h4>Agora executamos o webpack</h4>
    <br />
    <hr />
    <br />
    <h1>Utilizar plugins</h1>
    <br />
    <p>Vamos copiar a pasta anterior e mudar o nome para "Utilizar plugins"</p>
    <h4>
      Vamos utilizar o plugin "mini-css-extract-plugin" //É um plugin que serve
      para ir buscar o css que está incluso no webpack e criar um arquivo
      separado na saída
    </h4>
    <h3>Vamos instalar o plugin:</h3>
    <h4>
      npm install --save-dev mini-css-extact-plugin //instalção com dependecia
      de desenvolvimento
    </h4>
    <h3>
      Agora vamos começar a utilizá-lo e mais uma vez, vamos ao arquivo do
      webpack "webpack.config.js"
    </h3>
    <h4>
      Primeiro precisamos de importar o plugin da propria biblioteca: const
      miniCssExtractPlugin = require("mini-css-extract-plugin")
    </h4>
    <h3>
      Agora no nosso module.exports, criámos outra chave com o nome: plugins
    </h3>
    <h4>Chave essa que tem como valor um array. plugins:[]</h4>
    <h3>
      Dentro desse array, passamos os plugins que vamos utilizar; Neste plugin
      (mini-css-extract-plugin) para passar os plugins que vamos utilizar,
      precisamos de criar uma instancia dele e uma função construtora
    </h3>
    <h4>instacia é algo que criamos com a palavra "new"</h4>
    <h4>
      função construtora é uma função que devolve um objeto desta class
      (miniCssExtractPlugin)
    </h4>
    <h4>plugins: [new miniCssExtractPlugin()]</h4>
    <h3>Feito isto, agora precisamos de dizer COMO é que vamos utilizá-lo</h3>
    <h4>
      Vamos às nossas "rules" e vamos tirar o nosso "style-loader" e substituir
      pelo loader do proprio plugin: miniCssExtractPlugin.loader
    </h4>
    <h3>o ficheiro "webpack.config.js" fica:</h3>
    <p>const miniCssExtractPlugin = require("mini-css-extract-plugin");</p>
    <p>module.exports = {</p>
    <p>entry: {</p>
    <p>index: "./src/index.js",</p>
    <p>},</p>
    <p>mode: "development",</p>
    <p>module: {</p>
    <p>rules: [</p>
    <p>{</p>
    <p>test: /\.css$/,</p>
    <p>use: [miniCssExtractPlugin.loader, "css-loader"],</p>
    <p>},</p>
    <p>],</p>
    <p>},</p>
    <p>plugins: [new miniCssExtractPlugin()],</p>
    <p>};</p>
    <h4>executamos o webpack: npx webpack</h4>
    <h4>Podemos ver que na pasta "dist" foi criado o ficheiro index.css</h4>
    <h4>
      Agora no ficheiro "index.html" podemos incluir o arquivo css que foi
      criado: link rel="stylesheet" href="index.css"
    </h4>
    <br />
    <hr />
    <br />
    <h1></h1>
  </body>
</html>
